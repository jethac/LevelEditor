//Sony Computer Entertainment Confidential

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;

using Sce.Atf.Dom;

namespace DomGen
{


    public class NativeCodeGen
    {
        private static class ConstStrings
        {
            public const string IncludeFileName = "RegisterSchemaObjects.h";
            public const string ObjectID = "ObjectGUID";
            public const string ObjectTypeID = "ObjectTypeGUID";
            public const string ObjectPropertyID = "ObjectPropertyUID";
            public const string ObjectListID = "ObjectListUID";
        }

        // Generates 'native' C++ code from the info.
        public string Generate(NativeSchemaInfo info, string codeNamespace, string inputFile)
        {
            StringBuilder sb = new StringBuilder();
            GenerateFileProlog(sb, codeNamespace, inputFile);
            GenerateFunctionDefinitions(sb, info.NativeClasses);
            GenerateFunctionRegistration(sb, info.NativeClasses);
            GenerateFileEpilog(sb, codeNamespace);
            return sb.ToString();
        }

        private static void GenerateFileProlog(StringBuilder sb, string codeNamespace, string inputFile)
        {
            WriteLine(sb, "//-----------------------------------------------------------------------------");
            WriteLine(sb, "// This file auto generated by CodeGenDom from:");
            WriteLine(sb, "// {0}", inputFile);
            WriteLine(sb, "//-----------------------------------------------------------------------------");
            WriteLine(sb, "#include \"{0}\"", ConstStrings.IncludeFileName);

            WriteLine(sb,"// disable warning C4100 unreferenced formal parameter for this file");
            WriteLine(sb,"#pragma warning(push)");
            WriteLine(sb,"#pragma warning(disable: 4100)");

            WriteLine(sb, "namespace {0}", codeNamespace);
            WriteLine(sb, "{{");
        }

        private static void GenerateFileEpilog(StringBuilder sb, string codeNamespace)
        {
            WriteLine(sb, "}}; // end namespace {0}", codeNamespace);
            WriteLine(sb, "#pragma warning(pop)");
        }

        private static void GenerateFunctionDefinitions(StringBuilder sb, List<NativeClassInfo> classes)
        {
            WriteLine(sb, "");
            WriteLine(sb, "//-----------------------------------------------------------------------------");
            WriteLine(sb, "// DEFINITIONS");
            WriteLine(sb, "//-----------------------------------------------------------------------------");
            foreach (NativeClassInfo classInfo in classes)
            {
                GenerateClassDefinition(sb, classInfo);
                foreach (NativePropertyInfo propInfo in classInfo.Properties)
                {
                    GeneratePropertyDefinition(sb, classInfo, propInfo);
                }
                foreach (NativeListInfo listInfo in classInfo.Lists)
                {
                    GenerateListDefinition(sb, classInfo, listInfo);
                }
                WriteLine(sb, "");
            }
            WriteLine(sb, "");
        }
        private static void GenerateFunctionRegistration(StringBuilder sb, List<NativeClassInfo> classes)
        {
            WriteLine(sb, "");
            WriteLine(sb, "//-----------------------------------------------------------------------------");
            WriteLine(sb, "// REGISTRATION");
            WriteLine(sb, "//-----------------------------------------------------------------------------");
            WriteLine(sb, "");
            WriteLine(sb, "//-----------------------------------------------------------------------------");
            WriteLine(sb, "void InitGobBridge(GobBridge& bridge)");
            WriteLine(sb, "{{");
            foreach (NativeClassInfo classInfo in classes)
            {
                GenerateClassRegistration(sb, classInfo);
                foreach (NativePropertyInfo propInfo in classInfo.Properties)
                {
                    GeneratePropertyRegistration(sb, classInfo, propInfo);
                }
                foreach (NativeListInfo listInfo in classInfo.Lists)
                {
                    GenerateListRegistration(sb, classInfo, listInfo);
                }
                WriteLine(sb, "");
            }
            WriteLine(sb, "}}");
        }

        private static void GenerateClassRegistration(StringBuilder sb, NativeClassInfo classInfo)
        {
            WriteLine(sb, "  bridge.RegisterObject( \"{0}\", &{0}_Create );", classInfo.NativeName);
        }
        private static void GenerateClassDefinition(StringBuilder sb, NativeClassInfo classInfo)
        {
            WriteLine(sb, "//-----------------------------------------------------------------------------");
            WriteLine(sb, "//{0}", classInfo.NativeName);
            WriteLine(sb, "//-----------------------------------------------------------------------------");

            // object creation function
            WriteLine(sb, "Object* {0}_Create({1} tid, void* data, int size)", classInfo.NativeName, ConstStrings.ObjectTypeID);
            WriteLine(sb, "{{");
            if (classInfo.Abstract)
            {
                WriteLine(sb, "    assert(0); // class {0} is defined as abstract.", classInfo.NativeName);
                WriteLine(sb, "    return NULL;", classInfo.NativeName);
            }
            else
            {
                WriteLine(sb, "    return new {0}();", classInfo.NativeName);
            }
            WriteLine(sb, "}}");
        }

        private static void GeneratePropertyRegistration(StringBuilder sb, NativeClassInfo classInfo, NativePropertyInfo info)
        {
            string setFunc = info.Setable ? String.Format("&{0}_{1}_Set", classInfo.NativeName, info.NativeName) : "NULL";
            string getFunc = info.Getable ? String.Format("&{0}_{1}_Get", classInfo.NativeName, info.NativeName) : "NULL";
            WriteLine(sb, "  bridge.RegisterProperty( \"{0}\", \"{1}\", {3}, {4} );", classInfo.NativeName, info.NativeName, info.NativeType, setFunc, getFunc);
        }
        private static void GeneratePropertyDefinition(StringBuilder sb, NativeClassInfo classInfo, NativePropertyInfo info)
        {
            WriteLine(sb, "");
            if (info.Setable)
            {
                WriteLine(sb, "//-----------------------------------------------------------------------------");
                WriteLine(sb, "void {0}_{1}_Set({2} instanceId, void* data, int size)", classInfo.NativeName, info.NativeName, ConstStrings.ObjectID);
                WriteLine(sb, "{{");
                WriteLine(sb, "    assert((data && size > 0) || (!data && size == 0));");
                WriteLine(sb, "    {0}* instance = reinterpret_cast<{0}*>(instanceId);", classInfo.NativeName);
                switch (info.NativeType)
                {                    
                    case "Matrix":
                    case "AABB":
                    case "float2":                          
                    case "float3":                        
                    case "float4":                    
                    case "bool":                        
                    case "float":
                    case "int":
                    case "int8_t":
                    case "uint8_t":
                    case "int16_t":
                    case "uint16_t":
                    case "int32_t":
                    case "uint32_t":
                    case "int64_t":
                    case "uint64_t":
                        WriteLine(sb, "    {0} localData = *reinterpret_cast<{0}*>(data);", info.NativeType);
                        WriteLine(sb, "    instance->Set{0}(localData);", info.NativeName);
                        break;
                    case "wchar_t*":
                    case "char*":
                        WriteLine(sb, "    {0} localData = reinterpret_cast<{0}>(data);", info.NativeType);
                        WriteLine(sb, "    instance->Set{0}(localData);", info.NativeName);
                        break;
                    default:
                        WriteLine(sb, "    {0} localData = reinterpret_cast<{0}>(data);", info.NativeType);
                        WriteLine(sb, "    instance->Set{0}(localData, size);", info.NativeName);
                        break;

                }
                WriteLine(sb, "}}");
            }
            if (info.Getable)
            {
                WriteLine(sb, "//-----------------------------------------------------------------------------");
                WriteLine(sb, "void {0}_{1}_Get({2} instanceId, void** data, int* size)", classInfo.NativeName, info.NativeName, ConstStrings.ObjectID);
                WriteLine(sb, "{{");
                WriteLine(sb, "    {0}* instance = reinterpret_cast<{0}*>(instanceId);", classInfo.NativeName);
                WriteLine(sb, "    static {0} localData;", info.NativeType);
                WriteLine(sb, "    localData = instance->Get{0}();", info.NativeName);

                // need special handling for strings and wide strings here,
                // or you'll end up trying to marshal the memory address
                // instead of the contents into a managed string downstream
                switch(info.NativeType)
                {
                    case "wchar_t*":
                        WriteLine(sb, "    *data = (void*)localData;");
                        WriteLine(sb, "    *size = wcslen(localData);");
                        break;
                    case "char*":
                        WriteLine(sb, "    *data = (void*)localData;");
                        WriteLine(sb, "    *size = strlen(localData);");
                        break;

                    default:
                        WriteLine(sb, "    *data = (void*)&localData;");
                        WriteLine(sb, "    *size = sizeof(localData);");
                        break;
                }
                WriteLine(sb, "}}");
            }
        }

        private static void GenerateListRegistration(StringBuilder sb, NativeClassInfo classInfo, NativeListInfo info)
        {
            WriteLine(sb, "  bridge.RegisterChildList( \"{0}\", \"{1}\", &{0}_{1}_Add, &{0}_{1}_Remove);", classInfo.NativeName, info.NativeName, info.NativeType);
        }
        private static void GenerateListDefinition(StringBuilder sb, NativeClassInfo classInfo, NativeListInfo info)
        {
            WriteLine(sb, "");
            WriteLine(sb, "//-----------------------------------------------------------------------------");
            WriteLine(sb, "void {0}_{1}_Add({2} parentId, {2} childId, int index)", classInfo.NativeName, info.NativeName, ConstStrings.ObjectID);
            WriteLine(sb, "{{");
            WriteLine(sb, "    {0}* parent = reinterpret_cast<{0}*>(parentId);", classInfo.NativeName);
            WriteLine(sb, "    {0}* child = reinterpret_cast<{0}*>(childId);", info.NativeType);
            WriteLine(sb, "    parent->Add{0}(child, index);", info.NativeName);
            WriteLine(sb, "}}");
            WriteLine(sb, "");
            WriteLine(sb, "//-----------------------------------------------------------------------------");
            WriteLine(sb, "void {0}_{1}_Remove({2} parentId, {2} childId)", classInfo.NativeName, info.NativeName, ConstStrings.ObjectID);
            WriteLine(sb, "{{");
            WriteLine(sb, "    {0}* parent = reinterpret_cast<{0}*>(parentId);", classInfo.NativeName);
            WriteLine(sb, "    {0}* child = reinterpret_cast<{0}*>(childId);", info.NativeType);
            WriteLine(sb, "    parent->Remove{0}(child);", info.NativeName);
            WriteLine(sb, "}}");
        }

        private static void WriteLine(StringBuilder sb, string s, params object[] p)
        {
            sb.Append(string.Format(s, p));
            sb.Append(Environment.NewLine);
        }

    }
}
